<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CIS531</title>
    <description>CIS531 -- Compilers at Syracuse (Fall &apos;25)</description>
    <link>https://kmicinski.com/cis531-f25/</link>
    <atom:link href="https://kmicinski.com/cis531-f25/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 23 Aug 2025 15:10:49 -0400</pubDate>
    <lastBuildDate>Sat, 23 Aug 2025 15:10:49 -0400</lastBuildDate>
    <generator>Jekyll v4.4.1</generator>
    
      <item>
        <title>Week 1: Course Introduction and Racket</title>
        <description>&lt;h1 id=&quot;week-1-lecture-notes&quot;&gt;Week 1 Lecture Notes&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Class this week will be led by Neda, I (Kris) am away for previously-scheduled university business. We may have a short Zoom session on Monday if people would like to join, I will try to post a link to Blackboard.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Neda’s goal is to get you used to the basic workflow of booting up Dr. Racket, writing a tiny Racket program, and then being able to run that 
program on the command line. She will also demonstrate how this works on an Autograder project.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even though I will not be at class, I still ask that you watch the course videos–it is not much, and they are designed to be helpful. Generally I will lead class in-person, I understand that students will treat the videos as a reference. But at least when you’re starting, I really encourage you to do it at least for this week, especially as I will be gone.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I will not have office hours this week, please email me if you would like to meet–office hours will begin next Tuesday.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For the first week of the course, you should:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;If you haven’t used a command-line interface on your machine, you need to get comfortable using one. I recommend PowerShell on Windows (please read a quick tutorial to avoid wasting a lot of time) or iTerm2 (Mac OS). If you use Linux, you should use whatever terminal emulator you are most familiar with.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Make sure you have some version of Python 3 installed (type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; and see if anything happens).&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Make sure you add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;racket&lt;/code&gt; executable to your path by booting up Dr. Racket and doing Help-&amp;gt;Configure Racket for Command line…&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Next, you should make sure that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;racket&lt;/code&gt; is present in your path by typing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;racket&lt;/code&gt; and making sure you get a shell.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You should try practicing this workflow, writing a tiny Racket file like&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-hello.rkt&quot;&gt;(displayln &quot;Hello, World!&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then being able to do&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; racket hello.rkt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and see it print the corresponding string.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Neda will cover this workflow on Tuesday.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 14 Aug 2025 00:00:00 -0400</pubDate>
        <link>https://kmicinski.com/cis531-f25/notes/week/1</link>
        <guid isPermaLink="true">https://kmicinski.com/cis531-f25/notes/week/1</guid>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>Week 4: Algebraic Data Types</title>
        <description>&lt;h2 id=&quot;week-4-lecture-notes&quot;&gt;Week 4 Lecture Notes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;I have decided to shift the schedule around a little bit to match
course pacing, which does not affect the exam topics. I will talk
about algebraic data and pattern matching this week in class.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Code links from previous classes (the ones I have) are on Blackboard.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our goal today is to figure out how to use just simple cons cells to
build tree-shaped data structures. Tree-shaped, or &lt;em&gt;algebraic&lt;/em&gt; data
is a ubiqutuous topic in functional programming, which emphasizes
recursion (and induction) over tree-shaped data types, with finite
objects built using some (finite) number of &lt;em&gt;constructors&lt;/em&gt;
(functions) each of which has a corresponding sequence of arguments
(of some specific arity).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We will not study the formalization of algebraic data right now, but
to briefly summarize the mathematics: a sequence of arguments (as
input to a constructor) is characterized by a product type (a tuple
is characterized by a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; operation), and the ability to have
multiple constructors is characterized by a sum type. For this
reason, we call this kind of tree-shaped data, &lt;em&gt;algebraic data&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Last week in class, we talked about building lists with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cons&lt;/code&gt;. One
key idea to establish is that every list can be canonically
represented in the form:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(cons x0 (cons x1 ... (cons xn &apos;()) ...))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Every list is ultimately written something like the above, with each
individual cons cell represented as a heap-allocated (not with
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;malloc&lt;/code&gt; but some custom allocator that allocates cons cells
specifically) struct (a pair of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt; and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdr&lt;/code&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In Racket, lists are untyped, dynamic errors on lists happen when
the expected length (or type of the underlying data) does not match
the type expected by the code. This means that for now, we don’t
have to think about the types–but we do have to be careful with how
we use data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We will introduce the idea of “type predicates.” A type predicate is
a Racket function (returning only &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#t&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#f&lt;/code&gt;) which classifies
whether a given Racket value inhabits the type being defined. For
example, the following type predicate defines a simple type of
binary tree where each node contains some arbitrary value–there is
no type checking imposed upon the value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt; carried by the node.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define (tree? t)
  (match t
    [&apos;empty #t]
    [`(node ,v ,(? tree? t0) ,(? tree? t1)) #t]
    [_ #f]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above code uses pattern matching, we will walk through it in class
and carefully explain this example. Any time where you are using
pattern matching, you could also (with more typing) be explicit, and
build a large &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cond&lt;/code&gt; instead; using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cond&lt;/code&gt;, each condition checks
whether the pattern matches, and each corresponding branch extracts
the matched elements and computes with them. This is basically what
the pattern matcher is doing under the hood (but with the ability to
reason about some properties of the pattern and optimize the search,
potentially).&lt;/p&gt;

&lt;p&gt;Example trees here include:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(tree? &apos;empty) ;; #t
(tree? &apos;(node 1 empty empty)) ;; #t
(tree? &apos;(node 25 (node &quot;hello&quot; empty empty) empty)) ;; #t
(tree? &apos;(node &quot;hello&quot; 1 2)) ;; #f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Our type predicate will typically have the pattern:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define (type? t)
  (match t
    [... #t]
	...
	[_ #f]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In general, an algebraic type has a set of constructors–the type
predicate will be formed by building a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;match&lt;/code&gt; statement over each of
these constructors. For example, we might imagine a specification for
a set of unary or binary trees:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define (ubtree? t)
  (match t
    [&apos;empty #t]
    [`(unary ,v ,(? ubtree? t)) #t]
    [`(binary ,v ,(? ubtree? t0) ,(? ubtree? t1)) #t]
    [_ #f]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can read the Racket code as implementing a common English language
description of the corresponding inductive definition of lists (using
structural recursion to define the shape of lists):&lt;/p&gt;

&lt;p&gt;An value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubtree?&lt;/code&gt; iff it:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;is the specific symbol &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;empty&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A list of length three beginning with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;unary&lt;/code&gt; is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubtree?&lt;/code&gt;,
assuming the third element also has to be a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubtree?&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;A list of length four beginning with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;binary&lt;/code&gt; is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubtree?&lt;/code&gt;,
assuming its last two elements are also &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubtree?&lt;/code&gt;s.&lt;/li&gt;
  &lt;li&gt;Last, and importantly, no other types of values are &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubtree?s&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We eschew type theory at the moment, and in the first parts of this
course we will focus on operational semantics. The role of type theory
is to give a set of rules which can be run (and will necessarily
terminate) to decide these stipulations are met. In Racket, we do not
have a static type system–it is easier to check these properties
on-the-fly and allow them to dynamically fail. Also, in my
descriptions so far I’m cheating by not constraining the type of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;
in any way–in a static type system, we’d have to give &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt; a type as
well, and features like parametric polymorphism offer one way to
achieve this statically.&lt;/p&gt;

&lt;p&gt;So to sum it up, an algebraic data type is a type that is built out of
multiple constructors, each of which is allowed to take a specific
sequence of arguments. We will not explicitly build this type into the
type system in Racket (as Racket lacks a type system), but instead we
will write “type predicates,” functions which implement all of the
runtime checks necessary to operationalize the type.&lt;/p&gt;

&lt;p&gt;Programming with algebraic data involves matching on it. The great
news here is that &lt;em&gt;every usage of algebraically-defined data must
follow the same template as the type definition itself&lt;/em&gt;. This is not
just an idiom–it is a requirement to ensure that the semantics is
total, and prevent dynamic errors in the form of match failures. For
example, let’s say we have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance?&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define (distance? d)
  (match d
    [`(,(? integer?) feet) #t]
    [`(,(? integer?) miles) #t]
    [_ #f]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, if we have a function that expects distances, it would be an
error to write something like:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; distance? -&amp;gt; integer?
(define (to-inches d)
  (match d
    [`(,i feet) (* 12 i)]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The issue is that the match pattern is &lt;em&gt;non-exhaustive&lt;/em&gt; with respect to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance?&lt;/code&gt;. Again, just to be clear–the comment is not enforced by Racket &lt;em&gt;at all&lt;/em&gt;, it is a conceptual annotation of what expect the static type of the function to be. To see the bug, we can look at the following call:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(to-inches &apos;(5 miles))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to-inches&lt;/code&gt; has no match pattern for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;(5 miles)&lt;/code&gt;, and so it
raises a dynamic error. If Racket had a static type system (like Typed
Racket does), it could statically (at compile time) tell you that the
match was non-total–however, this is also an optional feature
(sometimes a compiler warning) in practice. But to us, it doesn’t seem
very meaningful of a distinction, since we’re still seeing the bug at
the same time. This becomes more important in larger developments,
where errors manifest possibly far away from the code in which they
originated (the “root cause” of the bug).&lt;/p&gt;

&lt;h2 id=&quot;read-the-documentation&quot;&gt;Read the Documentation&lt;/h2&gt;

&lt;p&gt;Here: &lt;a href=&quot;https://docs.racket-lang.org/guide/match.html&quot;&gt;https://docs.racket-lang.org/guide/match.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Let’s define a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shape?&lt;/code&gt; to be one of the following:
    &lt;ul&gt;
      &lt;li&gt;Rectangles can be shapes, and have to include points &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x0, y0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x1, y1&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Circles can be shapes, and have a starting point &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x0, y0&lt;/code&gt; and a radius &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; which is a real number&lt;/li&gt;
      &lt;li&gt;No other things are shapes.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Write this as a Racket type predicate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Define the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;area&lt;/code&gt; on the type predicate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shape?&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 03 Feb 2025 00:00:00 -0500</pubDate>
        <link>https://kmicinski.com/cis531-f25/notes/week/4</link>
        <guid isPermaLink="true">https://kmicinski.com/cis531-f25/notes/week/4</guid>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>Week 1: Course Introduction and Racket</title>
        <description>&lt;h1 id=&quot;week-2-lecture-notes&quot;&gt;Week 2 Lecture Notes&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;All Racket programs are built out of parentheses-enclosed
expressions called S-expressions. These S-expressions are “untyped”
in the sense that they are just symbolic data. They can nest, nested
S-expressions are akin to trees.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;We will discuss S-expressions more significantly later on in the
course.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 21 Jan 2025 00:00:00 -0500</pubDate>
        <link>https://kmicinski.com/cis531-f25/notes/week/2</link>
        <guid isPermaLink="true">https://kmicinski.com/cis531-f25/notes/week/2</guid>
        
        
        <category>notes</category>
        
      </item>
    
      <item>
        <title>Project 2: Transitive Closure</title>
        <description>&lt;p&gt;&lt;strong&gt;Due&lt;/strong&gt;: Wednesday, March 1st, 11:59PM.&lt;/p&gt;

&lt;p&gt;Available on http://autograde.org. Use your credentials to login.&lt;/p&gt;

&lt;p&gt;In this project we will implement a domain-specific programming
language that allows us to specify network topologies and check their
connectivity. Production datacenters and commercial networks are
composed of myriad hosts, routers, and switches, connected in a
complex web of infrastructure. An important but challenging question
is simply: which nodes may connect to which others?  Even in the
modern age, network misconfigurations still account for &lt;a href=&quot;https://www.forbes.com/sites/forbestechcouncil/2022/01/27/whats-causing-all-these-network-outages-and-what-can-cios-do-to-prevent-them/?sh=6dc268d37e7b&quot;&gt;global
internet outage
events&lt;/a&gt;. To
address this, several cloud providers have begun to provide tools for
analyzing properties of networks specified via domain-specific
configuration languages. For example, AWS’s &lt;a href=&quot;https://aws.amazon.com/blogs/aws/new-vpc-insights-analyzes-reachability-and-visibility-in-vpcs/&quot;&gt;VPC Reachability
Analyzer&lt;/a&gt;
is a commercial offering that is now used by some cloud system
engineers as part of their day-to-day jobs.&lt;/p&gt;

&lt;p&gt;In this project, we will build a minimal language for expressing
network topologies and implement transitive closure, the algorithm for
graph reachability. This will allow us to check for connectivity
properties of (potentially huge) graphs. Our language is loosely
inspired by &lt;a href=&quot;https://cornell-pl.github.io/cs6114/netkat.html&quot;&gt;NetKAT&lt;/a&gt;,
and we encourage you to read about its features if software-defined
networking is of interest to you.&lt;/p&gt;

&lt;h3 id=&quot;academic-integrity&quot;&gt;Academic Integrity&lt;/h3&gt;

&lt;p&gt;The coding on this project is to be completed by you alone, without
help from any other students. You are encouraged to discuss the
project specification at a high level, but should not discuss
specifics or show students your solution code.&lt;/p&gt;

&lt;h2 id=&quot;input-format&quot;&gt;Input Format&lt;/h2&gt;

&lt;p&gt;Networks include various pieces of physical infrastructure: routers,
switches, and servers. In this project we will ignore the
physical properties of network nodes, and will simply call every
entity capable of sending or receiving data a “node.” Nodes are
connected by (directed) links. Both nodes and links are specified as
commands, each command residing on a unique line of the input file
format. Syntactically, the two specification commands are (a) the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE &amp;lt;name&amp;gt;&lt;/code&gt; command, which specifies the existence of a node named
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;name&amp;gt;&lt;/code&gt; and (b) the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LINK &amp;lt;from&amp;gt; &amp;lt;to&amp;gt;&lt;/code&gt; command, which establishes a
(directed) link from node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;from&amp;gt;&lt;/code&gt; to node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;to&amp;gt;&lt;/code&gt;. For convenience, we
assume all nodes are specified before any occurrences of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LINK&lt;/code&gt;
commands. For example, the following is valid:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE node0-name
NODE node1-name
LINK node0-name node1-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But the next is not:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE node0-name
LINK node0-name node1-name
NODE node1-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can visualize the first graph in the following way:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    +------------+  link    +------------+
    | node0-name | -------&amp;gt; | node1-name |
    +------------+          +------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s add some more nodes and links:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE node0-name
NODE node1-name
NODE node2-name
LINK node0-name node1-name
LINK node1-name node2-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now our network looks like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    +------------+  link    +------------+  link    +------------+
    | node0-name | -------&amp;gt; | node1-name | -------&amp;gt; | node2-name |
    +------------+          +------------+          +------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;transitive-closure&quot;&gt;Transitive Closure&lt;/h1&gt;

&lt;p&gt;The above networks are toy examples. In practice, networks may have
millions of nodes, and orders-of-magnitude more links. Network
engineers work hard to ensure that networks are designed to adhere to
specific connectivity invariants. For example, we may wish to ensure
that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main-server&lt;/code&gt; can connect to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backup-srv&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE main-server
NODE backup-srv
NODE switch
NODE db-server
LINK main-server switch
LINK switch main-server
LINK switch backup-srv
LINK backup-srv switch
LINK db-server switch
LINK switch db-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that we explicitly enumerated bidirectional links. The above
specification may be visualized as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    +-------------+          +------------+          +------------+
    | main-server | &amp;lt;------&amp;gt; |   switch   | &amp;lt;------&amp;gt; | backup-srv |
    +-------------+          +------------+          +------------+
                                 ^
    +------------+               |
    | db-server  | &amp;lt;-------------+ 
    +------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, we can make queries:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CONNECT main-server backup-srv
CONNECT db-server main-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checking these queries is easy for small examples: we can trace in our
head a path between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main-server&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;db-server&lt;/code&gt;. But larger examples
may involve a great many nodes, and even more links between them. As
such, we need an algorithm which will infer &lt;em&gt;transitive&lt;/em&gt; links through
the input graph:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          +----------------------------------------------+
          v                                              v
    +-------------+          +------------+          +------------+
    | main-server | &amp;lt;------&amp;gt; |   switch   | &amp;lt;------&amp;gt; | backup-srv |
    +-------------+          +------------+          +------------+
          |                      ^                        ^
    +------------+               |                        |
    | db-server  | &amp;lt;-------------+                        |
    +------------+                                        |
          ^                                               |
          +-----------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We do this through an iterative process named &lt;em&gt;transitive
closure&lt;/em&gt;. Transitive closure consists of a series of steps applied in
an iterative fashion, until no more answers are possible. In other
words, the algorithm is defined in terms of its behavior at each “time
step.”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The transitive closure (of links) at time 0 is simply the set of
extensionally-specified (input) links.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To construct the transitive closure at time n+1, look at the
transitive closure at time n. For any pair of links in that graph,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,y)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(y,z)&lt;/code&gt;, such that the intermediate node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; is
matching, draw a (possibly new) link between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;z&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,z)&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repeat this process until no new links are found. I.e., until the
transitive closure at some time n is equal to the transitive closure
at time n+1&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This process necessarily terminates, as long as you are careful to
ensure elements are not added twice (which will be easy using the
correct datastructures, namely sets and hashes). This is because there
are a finite number of nodes, and so the “worst-case” scenario would
be that every node was connected to every other (as it is in the above
graph). At each step of the process, we add more information to
(monotonically) increase our knowledge base (of transitive links). At
some point we will either (a) not add any new links or (b) add all
possible links, at which point no more links may be added and we
terminate.&lt;/p&gt;

&lt;p&gt;A generalized version of this reasoning gives us the &lt;a href=&quot;https://en.wikipedia.org/wiki/Knaster%E2%80%93Tarski_theorem&quot;&gt;Knaster-Tarski fixed-point theorem&lt;/a&gt; and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kleene_fixed-point_theorem&quot;&gt;Klenne fixed-point theorem&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;hashes&quot;&gt;Hashes&lt;/h1&gt;

&lt;p&gt;We will represent graphs of links as Racket &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashes&lt;/code&gt;. We strongly
encourage you to read &lt;a href=&quot;https://docs.racket-lang.org/reference/hashtables.html&quot;&gt;their documentation&lt;/a&gt;. You
will need to know at least the following key functions: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash key0 value0
...)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash-ref key)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash-set hsh key value)&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash-keys
hsh)&lt;/code&gt;. Note: you are specifically &lt;strong&gt;forbidden&lt;/strong&gt; from using
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make-hash&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-set!&lt;/code&gt;, and other mutable variants of hashes.&lt;/p&gt;

&lt;p&gt;To represent a graph as a hash, we will adopt the following
representation: keys will be strings, and their associated values will
be &lt;strong&gt;sets&lt;/strong&gt; of strings, manipulated using Racket’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt;s (whose
&lt;a href=&quot;https://docs.racket-lang.org/reference/sets.html&quot;&gt;documentation you should read
here&lt;/a&gt;. For example,
the first example graph would be represented as&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define x (hash &quot;node0-name&quot; (set &quot;node1-name&quot;)
                &quot;node1-name&quot; (set &quot;node2-name&quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To add a new link to the graph, we must be careful to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-add&lt;/code&gt; to
extend the set of nodes. For example, consider that we wanted to
&lt;em&gt;extend&lt;/em&gt; the above graph with a pointer from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node0-name&lt;/code&gt; to
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node3-name&lt;/code&gt;, we would do it via the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(hash-set x &quot;node0-name&quot; (set-add (hash-ref x &quot;node0-name&quot;) &quot;node3-name&quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Make sure you understand in the above code how &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-add&lt;/code&gt; and
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-ref&lt;/code&gt; are used in combination to ensure that no
previously-present nodes are dropped.&lt;/p&gt;

&lt;h1 id=&quot;tasks&quot;&gt;Tasks&lt;/h1&gt;

&lt;p&gt;You will implement several functions, I have ranked them roughly in
order of difficulty.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(parse-line l)&lt;/code&gt; – You will parse an input line given as a string
and you will transform it into an output that conforms to
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;line?&lt;/code&gt;. Hint: use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string-split&lt;/code&gt; and matching. (Difficulty:
easy/medium)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(forward-link? graph n0 n1)&lt;/code&gt; – Check whether there is a forward
link from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n0&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n1&lt;/code&gt; in the graph &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graph&lt;/code&gt;. Return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#t&lt;/code&gt; iff &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n1&lt;/code&gt; is
linked to from (pointed at by) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n0&lt;/code&gt;. (Difficulty: easier)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(add-link graph from to)&lt;/code&gt; – Add an “edge” in the graph from node 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt; to node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to&lt;/code&gt;. Hint: use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-ref&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-add&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-set&lt;/code&gt; 
to accomplish this. (Difficulty: easier)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(build-init-graph input)&lt;/code&gt; – Assume that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;input&lt;/code&gt; is a program given
as input. You will build up an &lt;em&gt;initial&lt;/em&gt; graph datastructure
corresponding to the program. Essentially, you are building an
initial graph upon which you will subsequently perform iterative
rounds of transitive closure. You will do this by looking at each
line of input and changing the hash in one of two ways:&lt;/p&gt;

    &lt;p&gt;-&amp;gt; If you see a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node &amp;lt;n&amp;gt;)&lt;/code&gt; command, you will add a self link
  between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; and itself.
  -&amp;gt; If you see an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(link &amp;lt;from&amp;gt; &amp;lt;to&amp;gt;)&lt;/code&gt; command, you will insert an
  edge from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;(Difficulty: medium)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(transitive-closure graph)&lt;/code&gt; – Perform the transitive closure of
the graph &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graph&lt;/code&gt;. Your solution must be the final answer of
transitive closure, not just a single iteration. In other words,
your solution must possess the property that there are no additional
links possible to add. (Difficulty: harder)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;implementing-transitive-closure&quot;&gt;Implementing Transitive Closure&lt;/h3&gt;

&lt;p&gt;There are a variety of algorithms to implement transitive closure. I
will describe the so-called “naive” approach here, and then sketch a
more refined (semi-naive) approach. I would recommend you implement
your code using a combination of either recursive functions or the
functions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foldl/r&lt;/code&gt;. My solution is roughly ten lines and uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foldl&lt;/code&gt;
three times.&lt;/p&gt;

&lt;p&gt;Here is an iterative algorithm for calculating the transitive closure
of a graph.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Proceeding one iteration at a time, accumulate a variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At time step zero, initialize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt; to be the graph of initial
links.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To obtain the next time step, iterate over each edge in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,y)&lt;/code&gt; (this can be done using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-keys&lt;/code&gt; and a recursive function
or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foldl&lt;/code&gt;)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;For each of these edges, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,y)&lt;/code&gt; identify the set of edges
 starting from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(y,z)&lt;/code&gt;, add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,z)&lt;/code&gt; to the graph (this can be
 done using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-ref&lt;/code&gt;, which will return a set: you can iterate
 over that set as a list by using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-&amp;gt;list&lt;/code&gt;). Hint: you may want
 to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-ref&lt;/code&gt; with a third argument to specify a “default”
 value of the empty set (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash-ref h key (set))&lt;/code&gt;).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At some point this process will add no new edges, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt; at
timestep &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; will be the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt; at timestamp
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n+1&lt;/code&gt;. When this happens, the search is over.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As an example, let’s see what happens on the following&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE node0
NODE node1
NODE node2
LINK node0 node1
LINK node1 node2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We start with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt; being the graph &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{node0 -&amp;gt; {node1}, node1 -&amp;gt; {node2}}&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We examine edge &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node0,node1)&lt;/code&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Consider the set of edges beginning with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node1&lt;/code&gt;: this is just the
single edge &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node1,node2)&lt;/code&gt;. We add it to the graph, and now our
graph is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{node0 -&amp;gt; {node1, node2}, node1 -&amp;gt; {node2}}&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We examine edge &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node1,node2)&lt;/code&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Consider the set of edges beginning with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node2&lt;/code&gt;: there are no
such edges, so the graph doesn’t change.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At the end of the first iteration (time step), the graph is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{node0
-&amp;gt; {node1, node2}, node1 -&amp;gt; {node2}}&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;During the next iteration, we reexamine &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node1&lt;/code&gt;, but we
don’t discover any new edges, so the graph remains the same.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’re done: the final answer is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{node0 -&amp;gt; {node1, node2}, node1 -&amp;gt; {node2}}&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All in all my reference solution uses roughly 14 lines of code and
uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foldl&lt;/code&gt; several times. I predict reasonable solutions will be
between 10 and 50 lines, if you find yourself doing significantly more
work please consult the instructors to ensure you’ve got the algorithm
down.&lt;/p&gt;

&lt;h1 id=&quot;bonus-tests&quot;&gt;Bonus Tests&lt;/h1&gt;

&lt;p&gt;There are three bonus tests: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bonus-add-edge-3&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bonus-transitive-closure-ring100&lt;/code&gt;, and
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bonus-transitive-closure-ring200&lt;/code&gt;. The difference between these tests
and the normal (secret) tests is that they operate over much larger
graphs (the last two are ring graphs of size 200 and 300). To pass
these tests, ensure you don’t add extra algorithmic overhead to your
solution. The normal secret tests use graphs up to 30 nodes in
size. In sum, you can earn roughly 18% bonus.&lt;/p&gt;

&lt;h1 id=&quot;testing&quot;&gt;Testing&lt;/h1&gt;

&lt;p&gt;Once you implement all of your work, you will unlock the ability to 
run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connectivity.rkt&lt;/code&gt; with an input file. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demo&lt;/code&gt; function canonicalizes 
the database and prints out the starting database and its transitive closure:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;racket connectivity.rkt demo/1.net &quot;CONNECTED n13 n52&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will allow you to see your code in action. To run the testing
infrastructure on your code, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tester.py&lt;/code&gt;. It is invoked as
follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python3 tester.py -av
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You may wish to add more example networks in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demos&lt;/code&gt; folder.&lt;/p&gt;

&lt;h1 id=&quot;submitting-your-code-for-testing&quot;&gt;Submitting your code for testing&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; Before you can submit your project for grading you &lt;em&gt;must&lt;/em&gt; git
add, commit, and push. On a terminal (in your project directory)
type:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Add all files in the directory
git add .
# Make a commit
git commit -m &quot;my commit message here&quot;
# Push to server
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once you have done a git commit and push, go to the autograder and
select for your project to be graded.&lt;/p&gt;

&lt;h1 id=&quot;starter-code&quot;&gt;Starter Code&lt;/h1&gt;

&lt;p&gt;For those of you not currently enrolled in the class&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; Honor Pledge (bottom too) FILL IN NAME:
;;
;; I _____ submit this assignment as my own work
#lang racket
(provide (all-defined-out))

;;
;; CIS352 (Fall 22) Project 2 -- Network Connectivity
;; 

;; To see the demo, invoke using:
;;     racket connectivity.rkt &amp;lt;input-file&amp;gt;.net
;;     racket connectivity.rkt &amp;lt;input-file&amp;gt;.net &quot;CONNECTED &amp;lt;from&amp;gt; &amp;lt;to&amp;gt;&quot;

;; Lines are pared into an intermediate representation satisfying the
;; line? predicate.
(define (line? l)
  (match l
    [`(node ,(? string? node-name)) #t]
    [`(link ,(? string? from-node) ,(? string? to-node)) #t]
    [_ #f]))

;; The input format is a list of line?s
(define (input-format? lst)
  (and (list? lst)
       (andmap line? lst)))

;; A graph? is a hash table whose keys are strings and whose values
;; are sets of strings.
(define (graph? gr) (and (hash? gr)
                         (immutable? gr)
                         (andmap string? (hash-keys gr))
                         (andmap (lambda (key) (andmap string? (set-&amp;gt;list (hash-ref gr key))))
                                 (hash-keys gr))))


;; 
;; BEGIN PROJECT BELOW
;; 

;; TODO
;; Parse a line of text input. Lines will have the following format:
;;     NODE &amp;lt;node-name&amp;gt;
;;     LINK &amp;lt;node-name&amp;gt; &amp;lt;node-name&amp;gt;
;; 
;; Hint: use string-split and match, make sure to produce something
;; that adheres to `line?`.
(define/contract (parse-line l)
  (-&amp;gt; string? line?)
  ;; TODO TODO TODO 
  &apos;todo)

;; starter code
;; read a file by mapping over its lines  
(define/contract (read-file f)
  (-&amp;gt; string? input-format?)
  (map parse-line (file-&amp;gt;lines f)))

;; TODO 
;; Input is a list of line? commands. Write a recursive function which
;; builds up a hash.
;;
;; - If it&apos;s a `node` command, add a link from a node to itself.
;; - If it&apos;s a `link` command, add a directional link as specified.
;;
;; Hint: use (hash), (set n), hash-set, set-add, hash-ref, and similar.
(define/contract (build-init-graph input)
  (-&amp;gt; input-format? graph?)
  ;; TODO TODO TODO 
  (hash))

;; TODO
;; Check whether or not there is a forward line from n0 to n1 in
;; graph.
;; 
;; Hint: use set-member? and hash-ref
(define (forward-link? graph n0 n1)
  &apos;todo)

;; TODO
;; Add a directed link (from,to) to the graph graph, return the new graph with 
;; the additional link.
;;
;; Hint: use hash-set, hash-ref, and set-add.
(define (add-link graph from to)
  &apos;todo)

;; TODO
;; Perform the transitive closure of the graph. This is the most challenging 
;; operation in the project, so we recommend putting it off until the end.
;; 
;; To perform the transitive closure of the graph, iteratively add links
;; whenever you find a matching (x,y) and (y,z). This can be done in one of 
;; two broad ways: (a) chaotic iteration or (b) semi-naive evaluation. 
;; Read the project description for more details and hints at a solution.
;; 
;; My solution uses `foldl`, `hash-keys`, `set-&amp;gt;list`, `hash-ref`, and 
;; `add-link`. It is always possible to use a recursive helper function instead
;; of a foldl, but it makes the code much easier to understand in my opinion.
(define (transitive-closure graph)
  &apos;todo)


;;
;; END PROJECT CODE, DO NOT TOUCH BELOW
;;

;; Print a DB
(define (print-db db)
  (for ([key (sort (hash-keys db) string&amp;lt;?)])
    (displayln (format &quot;Key ~a:&quot; key))
    (displayln (string-append &quot;    &quot; (string-join (sort (set-&amp;gt;list (hash-ref db key)) string&amp;lt;?) &quot;, &quot;)))))

(define (demo file query)
  (define ir (read-file file))
  (define initial-db (build-init-graph ir))
  (displayln &quot;The input is:&quot;)
  (print-db initial-db)
  (displayln &quot;Now running transitive closure...&quot;)
  (define final-db (transitive-closure initial-db))
  (displayln &quot;Transitive closure:&quot;)
  (print-db final-db)
  (unless (equal? query &quot;&quot;)
    (match (string-split query)
      [`(&quot;CONNECTED&quot; ,n0 ,n1)
        (if (forward-link? final-db n0 n1)
          (displayln &quot;CONNECTED&quot;)
          (displayln &quot;DISCONNECTED&quot;))])))

(match-define (cons file query)
  (command-line
   #:program &quot;connectivity.rkt&quot;
   #:args ([filename &quot;&quot;]  [query &quot;&quot;])
   (cons filename query)))

;; if called with a single argument, this racket program will execute
;; the demo.
(if (not (equal? file &quot;&quot;)) (demo file query) (void))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 02 Oct 2022 00:00:00 -0400</pubDate>
        <link>https://kmicinski.com/cis531-f25/projects/2</link>
        <guid isPermaLink="true">https://kmicinski.com/cis531-f25/projects/2</guid>
        
        
        <category>assignment</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>Project 1: Tic-Tac-Toe</title>
        <description>&lt;p&gt;&lt;strong&gt;Due&lt;/strong&gt;: Wednesday, September 28th, 11:59PM.&lt;/p&gt;

&lt;p&gt;Please see the README file on the Autograder. We post the current version here for your reference.&lt;/p&gt;

</description>
        <pubDate>Sat, 17 Sep 2022 00:00:00 -0400</pubDate>
        <link>https://kmicinski.com/cis531-f25/projects/1</link>
        <guid isPermaLink="true">https://kmicinski.com/cis531-f25/projects/1</guid>
        
        
        <category>assignment</category>
        
        <category>project</category>
        
      </item>
    
  </channel>
</rss>

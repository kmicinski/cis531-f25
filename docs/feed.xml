<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CIS352</title>
    <description>CMSC352--Principles of Programming Languages (Spring '23) at Syracuse</description>
    <link>https://kmicinski.com/cis352-s23/</link>
    <atom:link href="https://kmicinski.com/cis352-s23/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 11 Jul 2023 13:31:59 -0400</pubDate>
    <lastBuildDate>Tue, 11 Jul 2023 13:31:59 -0400</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Project 2: Transitive Closure</title>
        <description>&lt;p&gt;&lt;strong&gt;Due&lt;/strong&gt;: Wednesday, March 1st, 11:59PM.&lt;/p&gt;

&lt;p&gt;Available on http://autograde.org. Use your credentials to login.&lt;/p&gt;

&lt;p&gt;In this project we will implement a domain-specific programming
language that allows us to specify network topologies and check their
connectivity. Production datacenters and commercial networks are
composed of myriad hosts, routers, and switches, connected in a
complex web of infrastructure. An important but challenging question
is simply: which nodes may connect to which others?  Even in the
modern age, network misconfigurations still account for &lt;a href=&quot;https://www.forbes.com/sites/forbestechcouncil/2022/01/27/whats-causing-all-these-network-outages-and-what-can-cios-do-to-prevent-them/?sh=6dc268d37e7b&quot;&gt;global
internet outage
events&lt;/a&gt;. To
address this, several cloud providers have begun to provide tools for
analyzing properties of networks specified via domain-specific
configuration languages. For example, AWS’s &lt;a href=&quot;https://aws.amazon.com/blogs/aws/new-vpc-insights-analyzes-reachability-and-visibility-in-vpcs/&quot;&gt;VPC Reachability
Analyzer&lt;/a&gt;
is a commercial offering that is now used by some cloud system
engineers as part of their day-to-day jobs.&lt;/p&gt;

&lt;p&gt;In this project, we will build a minimal language for expressing
network topologies and implement transitive closure, the algorithm for
graph reachability. This will allow us to check for connectivity
properties of (potentially huge) graphs. Our language is loosely
inspired by &lt;a href=&quot;https://cornell-pl.github.io/cs6114/netkat.html&quot;&gt;NetKAT&lt;/a&gt;,
and we encourage you to read about its features if software-defined
networking is of interest to you.&lt;/p&gt;

&lt;h3 id=&quot;academic-integrity&quot;&gt;Academic Integrity&lt;/h3&gt;

&lt;p&gt;The coding on this project is to be completed by you alone, without
help from any other students. You are encouraged to discuss the
project specification at a high level, but should not discuss
specifics or show students your solution code.&lt;/p&gt;

&lt;h2 id=&quot;input-format&quot;&gt;Input Format&lt;/h2&gt;

&lt;p&gt;Networks include various pieces of physical infrastructure: routers,
switches, and servers. In this project we will ignore the
physical properties of network nodes, and will simply call every
entity capable of sending or receiving data a “node.” Nodes are
connected by (directed) links. Both nodes and links are specified as
commands, each command residing on a unique line of the input file
format. Syntactically, the two specification commands are (a) the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE &amp;lt;name&amp;gt;&lt;/code&gt; command, which specifies the existence of a node named
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;name&amp;gt;&lt;/code&gt; and (b) the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LINK &amp;lt;from&amp;gt; &amp;lt;to&amp;gt;&lt;/code&gt; command, which establishes a
(directed) link from node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;from&amp;gt;&lt;/code&gt; to node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;to&amp;gt;&lt;/code&gt;. For convenience, we
assume all nodes are specified before any occurrences of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LINK&lt;/code&gt;
commands. For example, the following is valid:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE node0-name
NODE node1-name
LINK node0-name node1-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But the next is not:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE node0-name
LINK node0-name node1-name
NODE node1-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can visualize the first graph in the following way:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    +------------+  link    +------------+
    | node0-name | -------&amp;gt; | node1-name |
    +------------+          +------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s add some more nodes and links:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE node0-name
NODE node1-name
NODE node2-name
LINK node0-name node1-name
LINK node1-name node2-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now our network looks like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    +------------+  link    +------------+  link    +------------+
    | node0-name | -------&amp;gt; | node1-name | -------&amp;gt; | node2-name |
    +------------+          +------------+          +------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;transitive-closure&quot;&gt;Transitive Closure&lt;/h1&gt;

&lt;p&gt;The above networks are toy examples. In practice, networks may have
millions of nodes, and orders-of-magnitude more links. Network
engineers work hard to ensure that networks are designed to adhere to
specific connectivity invariants. For example, we may wish to ensure
that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main-server&lt;/code&gt; can connect to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backup-srv&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE main-server
NODE backup-srv
NODE switch
NODE db-server
LINK main-server switch
LINK switch main-server
LINK switch backup-srv
LINK backup-srv switch
LINK db-server switch
LINK switch db-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that we explicitly enumerated bidirectional links. The above
specification may be visualized as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    +-------------+          +------------+          +------------+
    | main-server | &amp;lt;------&amp;gt; |   switch   | &amp;lt;------&amp;gt; | backup-srv |
    +-------------+          +------------+          +------------+
                                 ^
    +------------+               |
    | db-server  | &amp;lt;-------------+ 
    +------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, we can make queries:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CONNECT main-server backup-srv
CONNECT db-server main-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checking these queries is easy for small examples: we can trace in our
head a path between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main-server&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;db-server&lt;/code&gt;. But larger examples
may involve a great many nodes, and even more links between them. As
such, we need an algorithm which will infer &lt;em&gt;transitive&lt;/em&gt; links through
the input graph:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          +----------------------------------------------+
          v                                              v
    +-------------+          +------------+          +------------+
    | main-server | &amp;lt;------&amp;gt; |   switch   | &amp;lt;------&amp;gt; | backup-srv |
    +-------------+          +------------+          +------------+
          |                      ^                        ^
    +------------+               |                        |
    | db-server  | &amp;lt;-------------+                        |
    +------------+                                        |
          ^                                               |
          +-----------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We do this through an iterative process named &lt;em&gt;transitive
closure&lt;/em&gt;. Transitive closure consists of a series of steps applied in
an iterative fashion, until no more answers are possible. In other
words, the algorithm is defined in terms of its behavior at each “time
step.”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The transitive closure (of links) at time 0 is simply the set of
extensionally-specified (input) links.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To construct the transitive closure at time n+1, look at the
transitive closure at time n. For any pair of links in that graph,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,y)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(y,z)&lt;/code&gt;, such that the intermediate node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; is
matching, draw a (possibly new) link between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;z&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,z)&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repeat this process until no new links are found. I.e., until the
transitive closure at some time n is equal to the transitive closure
at time n+1&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This process necessarily terminates, as long as you are careful to
ensure elements are not added twice (which will be easy using the
correct datastructures, namely sets and hashes). This is because there
are a finite number of nodes, and so the “worst-case” scenario would
be that every node was connected to every other (as it is in the above
graph). At each step of the process, we add more information to
(monotonically) increase our knowledge base (of transitive links). At
some point we will either (a) not add any new links or (b) add all
possible links, at which point no more links may be added and we
terminate.&lt;/p&gt;

&lt;p&gt;A generalized version of this reasoning gives us the &lt;a href=&quot;https://en.wikipedia.org/wiki/Knaster%E2%80%93Tarski_theorem&quot;&gt;Knaster-Tarski fixed-point theorem&lt;/a&gt; and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kleene_fixed-point_theorem&quot;&gt;Klenne fixed-point theorem&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;hashes&quot;&gt;Hashes&lt;/h1&gt;

&lt;p&gt;We will represent graphs of links as Racket &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashes&lt;/code&gt;. We strongly
encourage you to read &lt;a href=&quot;https://docs.racket-lang.org/reference/hashtables.html&quot;&gt;their documentation&lt;/a&gt;. You
will need to know at least the following key functions: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash key0 value0
...)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash-ref key)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash-set hsh key value)&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash-keys
hsh)&lt;/code&gt;. Note: you are specifically &lt;strong&gt;forbidden&lt;/strong&gt; from using
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make-hash&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-set!&lt;/code&gt;, and other mutable variants of hashes.&lt;/p&gt;

&lt;p&gt;To represent a graph as a hash, we will adopt the following
representation: keys will be strings, and their associated values will
be &lt;strong&gt;sets&lt;/strong&gt; of strings, manipulated using Racket’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt;s (whose
&lt;a href=&quot;https://docs.racket-lang.org/reference/sets.html&quot;&gt;documentation you should read
here&lt;/a&gt;. For example,
the first example graph would be represented as&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define x (hash &quot;node0-name&quot; (set &quot;node1-name&quot;)
                &quot;node1-name&quot; (set &quot;node2-name&quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To add a new link to the graph, we must be careful to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-add&lt;/code&gt; to
extend the set of nodes. For example, consider that we wanted to
&lt;em&gt;extend&lt;/em&gt; the above graph with a pointer from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node0-name&lt;/code&gt; to
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node3-name&lt;/code&gt;, we would do it via the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(hash-set x &quot;node0-name&quot; (set-add (hash-ref x &quot;node0-name&quot;) &quot;node3-name&quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Make sure you understand in the above code how &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-add&lt;/code&gt; and
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-ref&lt;/code&gt; are used in combination to ensure that no
previously-present nodes are dropped.&lt;/p&gt;

&lt;h1 id=&quot;tasks&quot;&gt;Tasks&lt;/h1&gt;

&lt;p&gt;You will implement several functions, I have ranked them roughly in
order of difficulty.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(parse-line l)&lt;/code&gt; – You will parse an input line given as a string
and you will transform it into an output that conforms to
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;line?&lt;/code&gt;. Hint: use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string-split&lt;/code&gt; and matching. (Difficulty:
easy/medium)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(forward-link? graph n0 n1)&lt;/code&gt; – Check whether there is a forward
link from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n0&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n1&lt;/code&gt; in the graph &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graph&lt;/code&gt;. Return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#t&lt;/code&gt; iff &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n1&lt;/code&gt; is
linked to from (pointed at by) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n0&lt;/code&gt;. (Difficulty: easier)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(add-link graph from to)&lt;/code&gt; – Add an “edge” in the graph from node 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt; to node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to&lt;/code&gt;. Hint: use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-ref&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-add&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-set&lt;/code&gt; 
to accomplish this. (Difficulty: easier)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(build-init-graph input)&lt;/code&gt; – Assume that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;input&lt;/code&gt; is a program given
as input. You will build up an &lt;em&gt;initial&lt;/em&gt; graph datastructure
corresponding to the program. Essentially, you are building an
initial graph upon which you will subsequently perform iterative
rounds of transitive closure. You will do this by looking at each
line of input and changing the hash in one of two ways:&lt;/p&gt;

    &lt;p&gt;-&amp;gt; If you see a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node &amp;lt;n&amp;gt;)&lt;/code&gt; command, you will add a self link
  between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; and itself.
  -&amp;gt; If you see an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(link &amp;lt;from&amp;gt; &amp;lt;to&amp;gt;)&lt;/code&gt; command, you will insert an
  edge from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;(Difficulty: medium)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(transitive-closure graph)&lt;/code&gt; – Perform the transitive closure of
the graph &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graph&lt;/code&gt;. Your solution must be the final answer of
transitive closure, not just a single iteration. In other words,
your solution must possess the property that there are no additional
links possible to add. (Difficulty: harder)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;implementing-transitive-closure&quot;&gt;Implementing Transitive Closure&lt;/h3&gt;

&lt;p&gt;There are a variety of algorithms to implement transitive closure. I
will describe the so-called “naive” approach here, and then sketch a
more refined (semi-naive) approach. I would recommend you implement
your code using a combination of either recursive functions or the
functions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foldl/r&lt;/code&gt;. My solution is roughly ten lines and uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foldl&lt;/code&gt;
three times.&lt;/p&gt;

&lt;p&gt;Here is an iterative algorithm for calculating the transitive closure
of a graph.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Proceeding one iteration at a time, accumulate a variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At time step zero, initialize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt; to be the graph of initial
links.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To obtain the next time step, iterate over each edge in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,y)&lt;/code&gt; (this can be done using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-keys&lt;/code&gt; and a recursive function
or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foldl&lt;/code&gt;)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;For each of these edges, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,y)&lt;/code&gt; identify the set of edges
 starting from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(y,z)&lt;/code&gt;, add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,z)&lt;/code&gt; to the graph (this can be
 done using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-ref&lt;/code&gt;, which will return a set: you can iterate
 over that set as a list by using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-&amp;gt;list&lt;/code&gt;). Hint: you may want
 to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-ref&lt;/code&gt; with a third argument to specify a “default”
 value of the empty set (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(hash-ref h key (set))&lt;/code&gt;).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At some point this process will add no new edges, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt; at
timestep &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; will be the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt; at timestamp
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n+1&lt;/code&gt;. When this happens, the search is over.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As an example, let’s see what happens on the following&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NODE node0
NODE node1
NODE node2
LINK node0 node1
LINK node1 node2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We start with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;solution&lt;/code&gt; being the graph &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{node0 -&amp;gt; {node1}, node1 -&amp;gt; {node2}}&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We examine edge &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node0,node1)&lt;/code&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Consider the set of edges beginning with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node1&lt;/code&gt;: this is just the
single edge &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node1,node2)&lt;/code&gt;. We add it to the graph, and now our
graph is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{node0 -&amp;gt; {node1, node2}, node1 -&amp;gt; {node2}}&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We examine edge &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node1,node2)&lt;/code&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Consider the set of edges beginning with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node2&lt;/code&gt;: there are no
such edges, so the graph doesn’t change.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At the end of the first iteration (time step), the graph is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{node0
-&amp;gt; {node1, node2}, node1 -&amp;gt; {node2}}&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;During the next iteration, we reexamine &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node1&lt;/code&gt;, but we
don’t discover any new edges, so the graph remains the same.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’re done: the final answer is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{node0 -&amp;gt; {node1, node2}, node1 -&amp;gt; {node2}}&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All in all my reference solution uses roughly 14 lines of code and
uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foldl&lt;/code&gt; several times. I predict reasonable solutions will be
between 10 and 50 lines, if you find yourself doing significantly more
work please consult the instructors to ensure you’ve got the algorithm
down.&lt;/p&gt;

&lt;h1 id=&quot;bonus-tests&quot;&gt;Bonus Tests&lt;/h1&gt;

&lt;p&gt;There are three bonus tests: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bonus-add-edge-3&lt;/code&gt;,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bonus-transitive-closure-ring100&lt;/code&gt;, and
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bonus-transitive-closure-ring200&lt;/code&gt;. The difference between these tests
and the normal (secret) tests is that they operate over much larger
graphs (the last two are ring graphs of size 200 and 300). To pass
these tests, ensure you don’t add extra algorithmic overhead to your
solution. The normal secret tests use graphs up to 30 nodes in
size. In sum, you can earn roughly 18% bonus.&lt;/p&gt;

&lt;h1 id=&quot;testing&quot;&gt;Testing&lt;/h1&gt;

&lt;p&gt;Once you implement all of your work, you will unlock the ability to 
run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connectivity.rkt&lt;/code&gt; with an input file. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demo&lt;/code&gt; function canonicalizes 
the database and prints out the starting database and its transitive closure:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;racket connectivity.rkt demo/1.net &quot;CONNECTED n13 n52&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will allow you to see your code in action. To run the testing
infrastructure on your code, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tester.py&lt;/code&gt;. It is invoked as
follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python3 tester.py -av
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You may wish to add more example networks in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demos&lt;/code&gt; folder.&lt;/p&gt;

&lt;h1 id=&quot;submitting-your-code-for-testing&quot;&gt;Submitting your code for testing&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; Before you can submit your project for grading you &lt;em&gt;must&lt;/em&gt; git
add, commit, and push. On a terminal (in your project directory)
type:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Add all files in the directory
git add .
# Make a commit
git commit -m &quot;my commit message here&quot;
# Push to server
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once you have done a git commit and push, go to the autograder and
select for your project to be graded.&lt;/p&gt;

&lt;h1 id=&quot;starter-code&quot;&gt;Starter Code&lt;/h1&gt;

&lt;p&gt;For those of you not currently enrolled in the class&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; Honor Pledge (bottom too) FILL IN NAME:
;;
;; I _____ submit this assignment as my own work
#lang racket
(provide (all-defined-out))

;;
;; CIS352 (Fall 22) Project 2 -- Network Connectivity
;; 

;; To see the demo, invoke using:
;;     racket connectivity.rkt &amp;lt;input-file&amp;gt;.net
;;     racket connectivity.rkt &amp;lt;input-file&amp;gt;.net &quot;CONNECTED &amp;lt;from&amp;gt; &amp;lt;to&amp;gt;&quot;

;; Lines are pared into an intermediate representation satisfying the
;; line? predicate.
(define (line? l)
  (match l
    [`(node ,(? string? node-name)) #t]
    [`(link ,(? string? from-node) ,(? string? to-node)) #t]
    [_ #f]))

;; The input format is a list of line?s
(define (input-format? lst)
  (and (list? lst)
       (andmap line? lst)))

;; A graph? is a hash table whose keys are strings and whose values
;; are sets of strings.
(define (graph? gr) (and (hash? gr)
                         (immutable? gr)
                         (andmap string? (hash-keys gr))
                         (andmap (lambda (key) (andmap string? (set-&amp;gt;list (hash-ref gr key))))
                                 (hash-keys gr))))


;; 
;; BEGIN PROJECT BELOW
;; 

;; TODO
;; Parse a line of text input. Lines will have the following format:
;;     NODE &amp;lt;node-name&amp;gt;
;;     LINK &amp;lt;node-name&amp;gt; &amp;lt;node-name&amp;gt;
;; 
;; Hint: use string-split and match, make sure to produce something
;; that adheres to `line?`.
(define/contract (parse-line l)
  (-&amp;gt; string? line?)
  ;; TODO TODO TODO 
  'todo)

;; starter code
;; read a file by mapping over its lines  
(define/contract (read-file f)
  (-&amp;gt; string? input-format?)
  (map parse-line (file-&amp;gt;lines f)))

;; TODO 
;; Input is a list of line? commands. Write a recursive function which
;; builds up a hash.
;;
;; - If it's a `node` command, add a link from a node to itself.
;; - If it's a `link` command, add a directional link as specified.
;;
;; Hint: use (hash), (set n), hash-set, set-add, hash-ref, and similar.
(define/contract (build-init-graph input)
  (-&amp;gt; input-format? graph?)
  ;; TODO TODO TODO 
  (hash))

;; TODO
;; Check whether or not there is a forward line from n0 to n1 in
;; graph.
;; 
;; Hint: use set-member? and hash-ref
(define (forward-link? graph n0 n1)
  'todo)

;; TODO
;; Add a directed link (from,to) to the graph graph, return the new graph with 
;; the additional link.
;;
;; Hint: use hash-set, hash-ref, and set-add.
(define (add-link graph from to)
  'todo)

;; TODO
;; Perform the transitive closure of the graph. This is the most challenging 
;; operation in the project, so we recommend putting it off until the end.
;; 
;; To perform the transitive closure of the graph, iteratively add links
;; whenever you find a matching (x,y) and (y,z). This can be done in one of 
;; two broad ways: (a) chaotic iteration or (b) semi-naive evaluation. 
;; Read the project description for more details and hints at a solution.
;; 
;; My solution uses `foldl`, `hash-keys`, `set-&amp;gt;list`, `hash-ref`, and 
;; `add-link`. It is always possible to use a recursive helper function instead
;; of a foldl, but it makes the code much easier to understand in my opinion.
(define (transitive-closure graph)
  'todo)


;;
;; END PROJECT CODE, DO NOT TOUCH BELOW
;;

;; Print a DB
(define (print-db db)
  (for ([key (sort (hash-keys db) string&amp;lt;?)])
    (displayln (format &quot;Key ~a:&quot; key))
    (displayln (string-append &quot;    &quot; (string-join (sort (set-&amp;gt;list (hash-ref db key)) string&amp;lt;?) &quot;, &quot;)))))

(define (demo file query)
  (define ir (read-file file))
  (define initial-db (build-init-graph ir))
  (displayln &quot;The input is:&quot;)
  (print-db initial-db)
  (displayln &quot;Now running transitive closure...&quot;)
  (define final-db (transitive-closure initial-db))
  (displayln &quot;Transitive closure:&quot;)
  (print-db final-db)
  (unless (equal? query &quot;&quot;)
    (match (string-split query)
      [`(&quot;CONNECTED&quot; ,n0 ,n1)
        (if (forward-link? final-db n0 n1)
          (displayln &quot;CONNECTED&quot;)
          (displayln &quot;DISCONNECTED&quot;))])))

(match-define (cons file query)
  (command-line
   #:program &quot;connectivity.rkt&quot;
   #:args ([filename &quot;&quot;]  [query &quot;&quot;])
   (cons filename query)))

;; if called with a single argument, this racket program will execute
;; the demo.
(if (not (equal? file &quot;&quot;)) (demo file query) (void))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 02 Oct 2022 00:00:00 -0400</pubDate>
        <link>https://kmicinski.com/cis352-s23/projects/2</link>
        <guid isPermaLink="true">https://kmicinski.com/cis352-s23/projects/2</guid>
        
        
        <category>assignment</category>
        
        <category>project</category>
        
      </item>
    
      <item>
        <title>Project 1: ASCII Art</title>
        <description>&lt;p&gt;&lt;strong&gt;Due&lt;/strong&gt;: Wednesday, September 28th, 11:59PM.&lt;/p&gt;

&lt;p&gt;Available on http://autograde.org. Use your credentials to login.&lt;/p&gt;

&lt;p&gt;In this project, you will parse and render ASCII art diagrams. The
point of this project is to (a) get you used to extending code others
(I) have written, (b) practice with recursion, and (c) to understand
the basic concept of (de)compilation to an intermediate
representation. In this project, we will consume ASCII art diagrams&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.-----------------------------------------------------------------------------.
 |Es| |F1 |F2 |F3 |F4 |F5 | |F6 |F7 |F8 |F9 |F10|                  C= AMIGA   |
 |__| |___|___|___|___|___| |___|___|___|___|___|                             |
  _____________________________________________     ________    ___________   |
 |~  |! |&quot; |§ |$ |% |&amp;amp; |/ |( |) |= |? |` || |&amp;lt;-|   |Del|Help|  |{ |} |/ |* |  |
 |`__|1_|2_|3_|4_|5_|6_|7_|8_|9_|0_|ß_|´_|\_|__|   |___|____|  |[ |]_|__|__|  |
 |&amp;lt;-  |Q |W |E |R |T |Z |U |I |O |P |Ü |* |   ||               |7 |8 |9 |- |  |
 |-&amp;gt;__|__|__|__|__|__|__|__|__|__|__|__|+_|_  ||               |__|__|__|__|  |
 |Ctr|oC|A |S |D |F |G |H |J |K |L |Ö |Ä |^ |&amp;lt;'|               |4 |5 |6 |+ |  |
 |___|_L|__|__|__|__|__|__|__|__|__|__|__|#_|__|       __      |__|__|__|__|  |
 |^    |&amp;gt; |Y |X |C |V |B |N |M |; |: |_ |^     |      |A |     |1 |2 |3 |E |  |
 |_____|&amp;lt;_|__|__|__|__|__|__|__|,_|._|-_|______|    __||_|__   |__|__|__|n |  |
    |Alt|A  |                       |A  |Alt|      |&amp;lt;-|| |-&amp;gt;|  |0    |. |t |  |
    |___|___|_______________________|___|___|      |__|V_|__|  |_____|__|e_|  |
                                                                              |
 -----------------------------------------------------------------------------'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We will transform this into an “intermediate representation:” a list
of triples, each specifying an X/Y coordinate along with a character
to be printed. For example, the following line:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; = . =
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is encoded in our representation as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'((0 1 #\=) (0 3 #\.) (0 5 #\=))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You will implement a function, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw-ascii-diagram&lt;/code&gt;, which
subsequently renders these images. We (the instructors) have
implemented a function, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse-ascii-diagram&lt;/code&gt;, which &lt;em&gt;reads&lt;/em&gt; ASCII art
pictures into the diagram format. Together, we can think of these as
forming a kind of (de)compiler: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse-ascii-diagram&lt;/code&gt; reads an ASCII
diagram into our internal format and your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw-ascii-diagram&lt;/code&gt; then
outputs an equivalent photo. In terms of the following diagram,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output0&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output1&lt;/code&gt; must be equivalent.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ASCII Text   ---  displayln --&amp;gt; output0
        |                             ||
parse-ascii-diagram                   ||
        |                            equal?
 draw-ascii-diagram                   ||
        |                             ||
	    +---------- displayln ---&amp;gt; output1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You are encouraged to read the beginning of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ascii.rkt&lt;/code&gt; for a more
precise specification of the input format.&lt;/p&gt;

&lt;h2 id=&quot;academic-integrity&quot;&gt;Academic Integrity&lt;/h2&gt;

&lt;p&gt;The coding on this project is to be completed by you alone, without
help from any other students. You are encouraged to discuss the
project specification at a high level, but should not discuss
specifics or show students your solution code.&lt;/p&gt;

&lt;h1 id=&quot;tasks&quot;&gt;Tasks&lt;/h1&gt;

&lt;p&gt;You will implement three functions; look for each usage of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TODO&lt;/code&gt;. For
many functions, starter code is provided. You are allowed to change
the implementation (i.e., throw away) of any starter code if you find
it helps you, but the instructors discourage doing so.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(draw-ascii-line l)&lt;/code&gt; – Given an ASCII line (specified as a list of
triples), draw the line. Assume that all characters are on the same
line (i.e., ignore the line number). Returns a string, which will be
printed by the testing infrastructure. This is &lt;em&gt;very&lt;/em&gt; similar to the
problem on exercise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e0&lt;/code&gt;, but you must account for the line number
(which you should ignore).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(newlines n)&lt;/code&gt; – which renders &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; newlines in a row; returns a
string.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw-ascii-diagram&lt;/code&gt; – which renders an entire diagram. Your
solution should make use of the functions you have previously
defined to accomplish its task. Ensure you handle corner cases like
empty lines (no testcases will be provided which include trailing
newlines)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I would start with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;newlines&lt;/code&gt;, it is the easiest. Then move on to
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw-ascii-line&lt;/code&gt;. Finally, read the code carefully and implement
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw-ascii-diagram&lt;/code&gt;. If confused, consult the in-class examples and
starter code, and ask clarifying questions on Zulip and in class.&lt;/p&gt;

&lt;h1 id=&quot;testing&quot;&gt;Testing&lt;/h1&gt;

&lt;p&gt;This project has 6 public tests and 5 secret tests. You are encouraged
to test your code piecemeal in the REPL using the public tests. You
are also encouraged to create your own tests, or even (hint) use the
tests provided in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pictures&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;Once your code is working correctly, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demo&lt;/code&gt; function will work,
unlocking the ability to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ascii.rkt&lt;/code&gt; directly via the command
line to demo your solution. To do this type:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;racket ascii.rkt pictures/1.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have included a testing corpus of pictures in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pictures/*.txt&lt;/code&gt;. You
may add more pictures, but do not remove or change the ones in those
starter files.&lt;/p&gt;

&lt;p&gt;To run the testing infrastructure on your code, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tester.py&lt;/code&gt;. It is
invoked as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[kmicinski] ascii-art % python3 tester.py
---------------------

Running test: public-draw-0
     PASSED
---------------------
...
---------------------

Running test: secret-draw-line-2
     PASSED

===========================
Summary: 11 / 11 tests passed
===========================
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;submitting-your-code-for-testing&quot;&gt;Submitting your code for testing&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; Before you can submit your project for grading you &lt;em&gt;must&lt;/em&gt; git
add, commit, and push. At a terminal (in your project directory)
type:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Add all files in the directory
git add .
# Make a commit
git commit -m &quot;my commit message here&quot;
# Push to server
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once you have done a git commit and push, go to the Autograder and
select for your project commit to be graded.&lt;/p&gt;

&lt;h2 id=&quot;starter-code&quot;&gt;Starter code&lt;/h2&gt;

&lt;p&gt;For those interested who did not pay for the class (and thus access to
the autograder) but want to work the project.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#lang racket
(provide (all-defined-out))

;;
;; CIS352 (Fall '22) Project 1 -- ASCII Art
;; 

;; To see the demo, invoke using:
;;     racket ascii.rkt &amp;lt;ascii-art&amp;gt;.txt

;; READ, DON'T EDIT

;; A point is specified as a list of length three containing an (0)
;; X-column-index, (1) Y-column-index, and (2) character to draw at
;; the specified X/Y coordinate position.
;;
;; For example, '(5 4 #\+) specifies the point at (5,4) in the diagram
;; is #\+.
(define (point-spec? pt)
  (match pt
    ;; points are lists of size three specifying a line, column, and
    ;; character to be printed
    [`(,(? nonnegative-integer? line) ,(? nonnegative-integer? column) ,(? char? char)) #t]
    [_ #f]))

;; a digram is a list of valid point-spec?s
(define (diagram-spec? l)
  (and (list? l) (andmap (lambda (x) (point-spec? x)) l)))

;; Takes a list of strings, returns an (ordered) diagram-spec?
;;
;; The basic idea is to walk over each line using a recursive function
;; which tracks a counter for the line number. Within that function,
;; we split up the string into its constituent characters using
;; string-&amp;gt;list and use a *second* recursive walk over each character,
;; tracking the column number.
(define (parse-ascii-diagram lines)
  ;; parse a single line, characters is a list of char?s line-no
  ;; is current line number.
  (define (parse-line characters line-no)
    ;; for each character, chars is a list of char?s, col-no is
    ;; the number of the current column.
    (define (for-each-char chars col-no)
      (cond [(empty? chars) '()] ;; done, return
            [(equal? (first chars) #\space)
             ;; if the char is a space, skip it
             (for-each-char (rest chars) (add1 col-no))]
            [else
             (cons (list line-no col-no (first chars))
                   (for-each-char (rest chars) (add1 col-no)))]))
    (for-each-char characters 0))
  ;; for each line, lines-list is the rest of the lines, line-no is
  ;; current line number.
  (define (for-each-line lines-list line-no)
    (if (empty? lines-list)
        ;; we're done, return
        '()
        (let ([characters (string-&amp;gt;list (first lines-list))]
              [rest-lines (rest lines-list)])
          (append (parse-line characters line-no)
                  (for-each-line rest-lines (add1 line-no))))))
  (for-each-line lines 0))

;; YOUR CODE HERE -- EDIT BEYOND THIS

;; helper: generate n spaces
(define (spaces n) (make-string n #\space))

;; Note: this is slightly different than the version in exercise e0,
;; but only superficially, a line number (which you should ignore) is
;; added.
;; 
;; Assume `l` is a (length-3) list of points (defined above) whose
;; first element is a line number, second element is the column
;; position, and third element is the character to be rendered at that
;; line/column pair. You will return a string representing the line.
;; 
;; Assume that all characters are on the same line--another function
;; will wrap this function.
;; 
;; Example:
;;    (draw-ascii-line '((3 3 #\=) (3 4 #\=) (3 5 #\=) (3 7 . #\.)
;;                       (3 9 #\=) (3 10 #\=) (3 11 #\=)))
;; &amp;gt; &quot;   === . ===&quot;
(define (draw-ascii-line l)
  ;; for each point
  (define (h l cur-pos)
    (if (empty? l)
      &quot;&quot;
      ;; else
      (let ([next-index (second (first l))]
            [next-char  (third (first l))]
            [rest-list  (rest l)])
        ;; TODO TODO TODO TODO
        'todo)))
  ;; assume input is sorted ascending on column number
  (h l 0))

;; Given a list of points, return the number of the next line. Assume
;; the list l is nonempty (calling this function on an empty list is
;; an error)
(define (line-number l)
  (first (first l)))

;; This function is implemented for you to use
;; 
;; Given a list of points, grab the next &quot;line&quot; from the input, return
;; (a) the next line and (b) the rest of the input.
(define (grab-next-line points)
  ;; conceptually: recur over l, consing on the next element as long
  ;; as it is on the next line
  (define (h lst)
    (match lst
      ['() (cons '() '())]
      [`(,hd . ,rest) (if (equal? (first hd) (line-number points)) 
                          (let ([rest-ans (h rest)])
                            (cons (cons hd (car rest-ans)) (cdr rest-ans)))
                          (cons '() rest))]))
  (h points))

;; generate a string of n newlines in a row
(define (newlines n)
  ;; TODO TODO TODO TODO
  &quot;todo&quot;)

;; Draw a whole ASCII diagram, given as a list of point
;; specifications.
(define (draw-ascii-diagram diagram)
  (define (do-lines lst line-no)
    (if (empty? lst)
        &quot;&quot;
        (let* ([parsed-line (grab-next-line lst)]
           [next-line (car parsed-line)]
           [rest-list (cdr parsed-line)]
           [next-line-no (line-number next-line)])
          ;; TODO TODO TODO TODO
          &quot;todo&quot;)))
  (do-lines diagram 0))

;; DO NOT EDIT BELOW HERE 

(define (demo file)
  (define lines (file-&amp;gt;lines file))
  (define input (string-join lines &quot;\n&quot;))
  (define diagram (parse-ascii-diagram lines))
  (define answer (draw-ascii-diagram diagram))
  (displayln &quot;The input is:&quot;)
  (displayln input)
  (displayln &quot;The decompiled diagram is:&quot;)
  (pretty-print diagram)
  (displayln &quot;Rendering this diagram produces the following:&quot;)
  (displayln (draw-ascii-diagram diagram))) 

(define file
  (command-line
   #:program &quot;ascii.rkt&quot;
   #:args ([filename &quot;&quot;])
   filename))

;; if called with a single argument, this racket program will execute
;; the demo.
(if (not (equal? file &quot;&quot;)) (demo file) (void)) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 17 Sep 2022 00:00:00 -0400</pubDate>
        <link>https://kmicinski.com/cis352-s23/projects/1</link>
        <guid isPermaLink="true">https://kmicinski.com/cis352-s23/projects/1</guid>
        
        
        <category>assignment</category>
        
        <category>project</category>
        
      </item>
    
  </channel>
</rss>
